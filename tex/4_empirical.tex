%!TEX root = ../document.tex
\chapter{Empirical settings and method}
The application is divided into three logical units: data collection, data processing and database, and user interface. In the following sections these units will be explained further. 

\section{Plant data collection}
At the lowest level in the information hierarchy we have the hardware and software responsible for capturing and uploading the environmental data regarding the plant. Like a patient in a hospital, the plant is connected to a range of sensors each responsible for reading a specific variable which is important for the plant’s functioning. These variables are then sent to a computer, and after processing, uploaded to the next level in the data hierarchy. In the following chapters we will follow the data on it’s way from the plant’s physical location to the cloud.

\subsection{Sensors}
With the advent of the \emph{“internet of things”}, sensors are becoming available in many different forms and packages. Just as LEGO-blocks they can be used in a wide range of applications. From automating tasks such as keeping a steady indoor-temperature, to measuring variables which we as humans cannot see. 

For this application we did a short review of the available off-the-shelf packages available on the market. 

The sensors are able to capture information about the environment and transform it to data variables which we can store and categorize. In total there are five different sensors connected to the plant, or in the plant’s vicinity: soil moisture, soil temperature, air temperature, humidity, and light. 


(write something about the sensortag)

The sensors we have used in this project works at the most basic level in the same way as a volume controller on an amplifier. On an amplifier one can adjust the volume by varying the resistance in the signal going to the speakers. If we turn the volume up, the resistance goes down, and if we turn the volume down, the resistance goes up. The concept with sensors is the same, only that instead of a human controlling the resistance, it is controlled by light, moisture or other environmental variables. 

The resistors used in the temperature sensors are called “thermistors”, and the way they operate is by varying the resistance according to the temperature. Since we already know how many volts we are sending to the thermistor on the one end, we can use the amount of volts we get back to calculate the resistance. In our application this is done by a voltage divider (formula ref)

If we solve this equation with regard to R2 we can see that the resistance is calculated to be X ohm. This value can then be mapped to the correct unit of measure, in this case Celsius or Fahrenheit. 
As we are using digital sensors, all of these calculations are done internally in the sensors, and coded into a digital signal. This signal, consisting of 1s and 0s, is then passed onto the next unit in our system, the Arduino.  

\subsection{Arduino}
(Write about embedded systems. What other alternatives are there to the Arduino? )

Arduino is an open-source prototyping (arduino.cc) platform which makes it easy to interface low-level electronics (e.g sensors) with higher-level electronics (e.g computers). The core part of the Arduino is an Atmel(tm) Atmega microcontroller which can be programmed by a computer over usb, using the Arduino programming language and the Arduino development environment (arduino.cc).

We have used an Arduino Uno which has 13 digital input output pins (GPIO), five analog inputs, i2c inputs, and USB for serial communication. The DSB18B20 soil temperature sensor and RHT03 temperature and humidity sensor are connected to the digital inputs through a 1K(ohm) pullup resistor. The pullup resistors are used to keep the voltage sent to the arduino from fluctuating when the sensor is not sending any data. The TSL2561 luminosity sensor is connected to the A4/SDA and A5/SDL ports of the Arduino as it communicates over the i2c protocol. And the generic soil moisture sensor is connected to A3 (Analog input 3) as it outputs analog voltage (not 1s and 0s).  

(illustration of schemadiagram)

The community surrounding Arduino is quite large, and therefore we were able to find pre-written libraries for communicating with the different sensors. This has made the task of converting the digital signal to the correct units (celsius, relative humidity, lux) and levels a breeze. 

In the case of the generic soil moisture sensor, it does not output soil moisture in any kind of universal unit. Therefore we measured the resistance in air (high resistance), and in water (low resistance), and let these be the high and low points of a new unit called arbitrary moisture units (AMU).

The code residing in the arduino runs a simple loop where it waits for a special character sent over serial communication through USB. If it receives this character it reads all the sensor values, and sends them back to the next logical unit: the Raspberry Pi

\subsection{Raspberry Pi}
(Why raspberry? Beagleboard?)
The Raspberry Pi is a “cheap, accessible, programmable computer” (http://www.raspberrypi.org/about) which is roughly the size of a credit card. Our model was released early 2012, and contains two usb ports, audio, sd-card slot, and several GPIO-pins. The devices connected to it are: wireless network adapter, high-definition webcamera, and the Arduino. The operating system running on it is a port of Debian Linux optimized for the Raspberry, called Raspbian. 

(illustration of raspberry)

The GPIO-pins on the raspberry works almost in the same fashion as the Arduino’s digital input output pins. Thus we could in theory simplified the hardware by omitting the Arduino. The main reason for not doing this is that the Raspberry does not have an analog to digital converter (ADC). Therefore we would have to make a complex circuit involving an ADC to interface the Raspberry with the soil moisture sensor. In addition to this, we would most likely face timing issues. When we ask the digital sensors for data, they send the response immediately. If the unit receiving is not available to read the data, it gets lost. This can be a problem when using a high-level computer, as it performs multiple other tasks in addition to reading sensordata. 

\subsubsection{Operation}
After booting up an endless loop bash-script is called. The script snaps a photo of the plant using the webcam, and then runs a python-script responsible for collecting sensordata. Since we sometimes can get erroneous values from the sensors, we decided to read 15 values and upload the median value.

%http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
\lstset{language=Python} 
\begin{lstlisting}
//instantiate lists
airtemp = []
humidity = []
light = []
soiltemp = [] 

for x in xrange(1,15): 
	ser.write("r") //Ask Arduino for data
	variables = ser.readline() //Read the data
	sensorReadings = variables.split('|') //Split string on |

	airtemp.append(float(sensorReadings[0]))
	humidity.append(float(sensorReadings[1]))
	light.append(float(sensorReadings[2]))
	soiltemp.append(float((sensorReadings[3])[:-2])) 

//calculate and post the median using numpy
postData(np.median(airtemp),np.median(humidity),np.median(light),np.median(soiltemp)) 
\end{lstlisting}

These values, along with the photo of the plant, are then passed on to the next instance, the API, using pythons HTTP-library urllib2. 

\section{Data processing and database}
When the data has been gathered at the low level hierarchy, it is stored in the cloud. This is done by posting the data to an API on our webserver. The main function of an API is to be a mean of communication between software, in our case the data collector and the user interface. After some research on web-API design, we decided that a REST architectual style was the way to go. 

\subsection{Representational State Transfer (REST)}
REST is an architectual style for distributed hypermedia systems \citep{fielding2000architectural}. In Fieldings dissertation, he writes about the interaction contraints of REST that is introduced in order to limit how a distributed system can be constructed. 

\begin{enumerate}
\item{} \emph{Client/Server} - This constraint seperates the concerns of the client and the server. By seperating these concerns, one secures that the two can evolve indepent of eachother. The client does not care about the internal logic of the server, and the server doesn’t care about what the client does with the data. This gives us the ability to seperate the concerns of data collection, data storage and data visualisation, which gives us the freedom to change the internal logic of any one of these without worrying about breaking the other two. It also means that we can create several different clients either for collecting data or displaying data.

\item{} \emph{Stateless} - This means that communication between client and server must be stateless. The request from client to server must contain all the information needed to understand the request. In practice this gives the client the responsibility to keep track of the state.

\item{} \emph{Caching} - In order to reduce requests and improve efficiency the server can state which responses can be reused by the client later, when sending equivalent requests. This can greatly enhance user-perceived performance, but at the same time reduce reliability if cached data differs from what would have been delivered by the server on a request. We could teoretically cache almost everything since our data belongs to specific timestamps, and the chances that a sensorvalue is updated at a later time is minimal. However, since we are developing a prototype and have the need for rapid changes in the implementation, we have experienced that the need for reliable data exceeds the need for fast performance.

\item{} \emph{Uniform interface} - This is a rather complex constraint in terms of RESTful API design, and is the reason for a lot of discussions around true REST on various forums on the web. Fielding describes a REST interface to be “efficient for large-grain hypermedia data transfer, optimizing for the common case of the Web, but resulting in an interface that is not optimal for other forms of architectural interaction.” (Fielding, 2000) In an applied context this means that the server has resources that can be referenced via URLs and operated through the http-verbs. This means that in order to be a true REST interface, an API can have any resource available through URLs, but the only methods in which one can operate the resource is POST, GET, PUT and DELETE.

\item{} \emph{Layered system} - This constraint tells us that a REST interface may hide complexity in a hierarchical way, by hiding infromation in such a way that each component cannot "see" beyond the immediate layer with which they are interacting. (Fielding 2000)

\item{} \emph{Code on demand} - An optional constraint, allowing the server to serve executable code to the client. 

\end{enumerate}

REST is an architectual style, not a strict standard, it allows for flexibility, but at the same time it promotes best practices. The goal of our API was to provide a way of storing and accessing plant data in the cloud, first and foremost for clientside applications that we build ourselves. The most important thing was to make something that worked for us. A pragmatic approach to REST gave us the flexibility to create an API that gets the job done. In the following chater we will describe how the API works and discuss some choices we made in the implementation process.

\subsection{Application Programming Interface - API}
Our first implementation of the API was written in PHP with the framework Codeigniter and a rest-server library as the base. We made a working version, but at some point, after making several dirty workarounds and hacks we started reading about Ruby on Rails and the design paradigm convention over configuration, and soon realized that Rails was exactly what we needed to build our API with.

\begin{quote}
"Ruby on Rails is an open-source web framework that’s optimized for programmer happinees and sustainable productivity. It lets you write beautyful code by favoring convention over configuration."\citep{rubyonrails.org} 
\end{quote}

Ruby on Rails is an open-source web framework that makes the assumption that there is a “best” way of doing things, and it encourages that way. It emphasizes well-known software engineering principles surch as convention over configuration, dont’repeat yourself, model-view-controller and REST.
 Our web server is running on Amazon Elastic Compute Cloud (ec2), a virtual computer service with low costs and exstensive configuration options. We chose this because we needed to be able to configure the server for our purposes and install several libraries and applications onto the server. We wanted to create the API The API is created with Ruby on Rails to 

Our API is a server-side Web-API which can be accessed through the http-protocol. This mean that to use it, one can send a request to the domain of the api from any client that has a way to send http-requests. The API will interpret the request and send back a response based on the how the interpretation went. Since our API is based on the REST architectual style, it adheres to how the http-protocol is buildt, meaning that a resource have a unique identifier a URI, and some uniform actions called the http-verbs which the resource can be operated with. There are 8 methods in the HTTP/1.1 protocol (Fielding et. al 1999), but only four of them are of interest when speaking of resources. These methods are the four basic functions of persistent storage in computer programming, often refered to as CRUD (Create, Read, Update and Delete), but in HTTP their names are POST, GET, PUT and DELETE.

The Monoplant API have three resources: Plants, Sensorvalues and Videos. To create a plant, one can send a POST request to the URL:

\begin{quote}
http://monoplant.me/plants.json 
\end{quote}

A post request also need information about the plant to create, in this case we will pass that information in the json-format:

\begin{lstlisting}[language=json]
 {"plant": {"name": "Alfa", "location": "Intermedia", "plant_type": "Alfalfaspire"}} 
\end{lstlisting}

For the api to know how to interpret this information in json, we also need to pass a parameter in the header called Content-type, this variable will be set to “application/json”. When we pass this request, the API will create a plant with the information we gave it, and give a response with the code: “201 created”. The response contains a header and a body in which the header has some metadata about the request and the body will contain a representation of the created plant (responseref 1).

\begin{lstlisting}[language=json]
{
	created_at: "2013-09-17T10:45:17+02:00"
	id: 1
	location: "Intermedia"
	name: "Alfa"
	plant_type: "Alfalfaspire"
	updated_at: "2013-09-17T10:45:17+02:00"
}
\end{lstlisting}

If we look at this representation, we see that the API have added an ID to the plant as well as two data attributes created\_at and updated\_at. Since we now have the id of the plant, we can tell the Raspberry Pi to start adding sensorvalues for the plant. The Raspberry will create a request using the data it gets from the arduino and the image from the webcam and finally send that POST request to the URL:

\begin{quote}
http://monoplant.me/plants/1/sensorvalues.json 
\end{quote}

As before the API will interpret the request, store the data and respond with a status code: “201 created”. But there is some more stuff happening in the background, the Raspberry only sent the sensorvalues and an image. Internally the API creates a thumbnail of the image and uploads both the thumbnail and the original to another static server, finally storing the url for both of them in the database. The resonse body ends up looking like (responseref 2):

\begin{lstlisting}[language=json]
{
	airTemp: 22.14
	created_at: "2013-09-17T10:49:43+02:00"
	humidity: 38.5
	id: 10037
	img_url: "http://s3-eu-west-1.amazonaws.com/plantespann/2013/9/17/original/10037.jpg?1379407782"
	light: 1702.5
	photo_content_type: "image/jpeg"
	photo_file_name: "viewcam.jpg"
	photo_file_size: 204358
	photo_updated_at: "2013-09-17T10:49:42+02:00"
	plant_id: 1
	soilMoisture: 54
	soilTemp: 22.25
	thumb_url: "http://s3-eu-west-1.amazonaws.com/plantespann/2013/9/17/thumb/10037.jpg?1379407782"
	updated_at: "2013-09-17T10:49:43+02:00"
}

\end{lstlisting}

If we need to look at this sensorvalue at a later time, we can simply do a GET request using the sensorvalue id:

\begin{quote}
http://monoplant.me/plants/1/sensorvalues/10037.json 
\end{quote}

This will make the API respond with a status code “302 Found”, and the body will look just like the previous response body, at least if nothing has been updated. Note that the URL is buildt up according to what resource we are trying to operate. 